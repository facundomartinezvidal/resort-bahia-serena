# **TRABAJO PRÁCTICO OBLIGATORIO**
# **INGENIERÍA DE DATOS I**

## **Sistema de Gestión Hotelera Integral**
### **Hotel Resort "Bahía Serena"**

---

**Universidad Argentina de la Empresa (UADE)**  
**Facultad de Ingeniería y Ciencias Exactas**  
**Ingeniería en Informática**

**Docentes:**  
Prof. Juan C. Montero | Prof. Julieta Viarengo

**Fecha:** Noviembre 2025

---

# **ÍNDICE**

**1. Resumen Ejecutivo**  
**2. Contexto y Alcance del Proyecto**  
**3. Análisis de Requerimientos**  
**4. Diseño Conceptual - Modelo Entidad-Relación**  
**5. Diseño Lógico - Modelo Relacional**  
**6. Proceso de Normalización**  
**7. Implementación Física - Definición de Datos**  
**8. Lógica de Negocio - Objetos de Base de Datos**  
**9. Flujo Operativo del Sistema**  
**10. Casos de Uso y Validaciones**  
**11. Buenas Prácticas y Consideraciones Técnicas**  
**12. Conclusiones y Trabajo Futuro**

---

# **1. RESUMEN EJECUTIVO**

El presente documento describe el diseño, desarrollo e implementación de un sistema integral de gestión hotelera para el Resort "Bahía Serena", desarrollado como Trabajo Práctico Obligatorio para la asignatura Ingeniería de Datos I de la carrera de Ingeniería en Informática de la Universidad Argentina de la Empresa.

El proyecto aborda la necesidad de centralizar y automatizar los procesos operativos de un establecimiento hotelero de categoría cuatro estrellas que combina servicios de alojamiento premium con experiencias recreativas y gastronómicas. La solución implementada contempla la gestión completa del ciclo de vida de las reservas, desde la disponibilidad de inventario hasta la facturación final, incorporando validaciones de integridad, trazabilidad de operaciones y un sistema robusto de alertas operativas.

La arquitectura de datos propuesta se fundamenta en los principios de diseño relacional, implementando un modelo normalizado hasta la tercera forma normal que garantiza la consistencia, elimina redundancias y facilita el mantenimiento evolutivo del sistema. La implementación física se realizó sobre Microsoft SQL Server, aprovechando las capacidades avanzadas de Transact-SQL para la construcción de objetos de lógica de negocio que incluyen procedimientos almacenados, funciones escalares, triggers de validación, cursores de procesamiento batch y vistas materializadas para reportería.

El sistema desarrollado resuelve problemáticas críticas identificadas en la operación actual del resort, tales como la duplicación involuntaria de reservas, la inconsistencia en la aplicación de tarifas dinámicas, el control inadecuado de estados de habitación y la ausencia de mecanismos de auditoría. La solución propuesta no solo automatiza estos controles sino que además proporciona las bases para una gestión estratégica del negocio mediante la generación de información consolidada para la toma de decisiones gerenciales.

---

# **2. CONTEXTO Y ALCANCE DEL PROYECTO**

## **2.1. Descripción del Negocio**

Bahía Serena es un hotel resort frente al mar que se posiciona en el segmento de turismo premium, combinando servicios de alojamiento de alta calidad con una amplia gama de experiencias diseñadas para satisfacer las necesidades de tres segmentos de mercado claramente diferenciados. El primero de ellos corresponde a familias que buscan experiencias vacacionales completas, donde la variedad de actividades recreativas y la seguridad del entorno son factores determinantes en la decisión de compra. El segundo segmento está conformado por parejas que priorizan el descanso, la privacidad y experiencias románticas, demandando servicios personalizados y espacios exclusivos. Finalmente, el tercer segmento comprende a viajeros corporativos que requieren facilidades para trabajo remoto, servicios ejecutivos eficientes y la posibilidad de realizar eventos empresariales en instalaciones apropiadas.

La infraestructura del establecimiento ha sido diseñada considerando esta diversidad de perfiles, ofreciendo tres categorías de habitación que se ajustan a diferentes necesidades y presupuestos. Las habitaciones tipo Estándar proporcionan confort básico con todas las amenidades necesarias, representando la opción de entrada al resort. Las habitaciones Superior incorporan espacios más amplios, mobiliario premium y detalles de diseño que elevan la experiencia del huésped. Por su parte, las Suites ofrecen el máximo nivel de confort con áreas separadas de descanso y trabajo, amenidades exclusivas y servicios diferenciados que justifican su posicionamiento en el segmento alto del mercado.

Un elemento diferenciador del resort es la gestión estratégica de las vistas que ofrece cada habitación. Las unidades con vista al mar representan el producto estrella, permitiendo a los huéspedes disfrutar del paisaje oceánico desde la privacidad de su habitación. Las habitaciones con vista al jardín proporcionan una experiencia de conexión con la naturaleza en un entorno más tranquilo y privado. Las habitaciones con vista interna, si bien no ofrecen panorámicas exteriores, compensan esta característica con tarifas más accesibles, permitiendo que el resort atienda a segmentos con diferentes capacidades de gasto.

Complementando la oferta de alojamiento, el resort ha desarrollado un portafolio integral de servicios adicionales que generan flujos de ingresos complementarios y enriquecen la propuesta de valor. El área de Spa y Wellness ofrece tratamientos especializados que incluyen masajes terapéuticos, tratamientos faciales, aromaterapia y sesiones de relajación diseñadas por profesionales certificados. El servicio de traslado al aeropuerto proporciona comodidad y seguridad a los huéspedes, eliminando las complejidades de la movilidad en destinos turísticos. La oferta gastronómica se extiende más allá del restaurant principal mediante cenas temáticas que celebran diferentes culturas culinarias, creando experiencias memorables que los huéspedes asocian positivamente con su estadía. Las excursiones constituyen otro pilar importante de la propuesta de valor, con tours especialmente diseñados para aprovechar las condiciones naturales del entorno, mientras que el servicio de alquiler de equipamiento facilita la movilidad autónoma y el descubrimiento de los alrededores.

## **2.2. Problemática y Justificación del Sistema**

La operación del resort, como sucede en numerosos establecimientos del sector hospitalidad que han crecido orgánicamente sin una planificación sistémica de sus procesos tecnológicos, enfrentaba múltiples desafíos que comprometían tanto la eficiencia operativa como la calidad del servicio al cliente. El análisis de la situación actual reveló la existencia de problemas estructurales que requerían una intervención integral mediante la implementación de un sistema de gestión robusto y confiable.

El primero de estos desafíos correspondía a la duplicación involuntaria de reservas, un problema que surgía cuando los clientes, utilizando la interfaz web de reservas, generaban múltiples solicitudes para la misma habitación en las mismas fechas. Esta situación podía originarse por diversas causas técnicas y de usabilidad, incluyendo respuestas lentas del servidor que llevaban a los usuarios a realizar múltiples clics en el botón de confirmación, problemas de conectividad que interrumpían la comunicación en momentos críticos del proceso transaccional, o simplemente confusión en la navegación de la interfaz que llevaba a los usuarios a repetir pasos ya completados. Las consecuencias de este problema eran múltiples y significativas, generando confusión en el inventario de habitaciones disponibles, creando registros duplicados que dificultaban la conciliación de datos, ocasionando errores en la facturación que derivaban en reclamos de clientes y, en última instancia, deteriorando la imagen profesional del establecimiento.

La inconsistencia en la gestión de precios representaba otro desafío crítico que afectaba simultáneamente la transparencia hacia los clientes y la capacidad de análisis financiero del negocio. El sistema vigente no mantenía un registro histórico adecuado de las tarifas aplicadas en cada transacción, lo que generaba situaciones problemáticas cuando las tarifas base eran modificadas. Los clientes que habían realizado reservas anticipadas con tarifas promocionales posteriormente veían cómo sus confirmaciones mostraban precios diferentes a los pactados originalmente, generando disputas que el personal de atención al cliente debía resolver sin contar con documentación respaldatoria. Esta carencia de trazabilidad también imposibilitaba análisis retrospectivos de rentabilidad por período, dificultando la evaluación de la efectividad de estrategias de pricing y la toma de decisiones fundamentadas sobre políticas comerciales futuras.

El control inadecuado del inventario de habitaciones constituía el tercer problema significativo identificado. La gestión manual de los estados operativos de las habitaciones generaba situaciones donde unidades que se encontraban en mantenimiento o fuera de servicio por diversas razones seguían apareciendo como disponibles en el sistema de reservas. Esta desconexión entre la realidad operativa y la información del sistema llevaba a situaciones embarazosas donde el personal de recepción debía informar a huéspedes con reservas confirmadas que sus habitaciones no estaban disponibles, requiriendo relocalizaciones de último momento que deterioraban la experiencia del cliente y generaban costos adicionales para el resort.

La gestión de temporadas y la aplicación de precios dinámicos representaba un cuarto desafío que limitaba la capacidad del resort para maximizar sus ingresos. El sector hotelero requiere sofisticación en la gestión de tarifas, aplicando estrategias de revenue management que ajustan precios según la demanda esperada, la anticipación de la reserva, la ocupación actual y múltiples factores adicionales. Sin embargo, el sistema existente carecía de mecanismos ágiles para definir y aplicar estas políticas de pricing, resultando en una gestión de tarifas excesivamente rígida que no capitalizaba oportunidades de maximizar ingresos durante períodos de alta demanda y no facilitaba la competitividad mediante precios atractivos durante temporadas bajas.

El control inadecuado de los cupos de servicios adicionales generaba otro conjunto de problemas operativos. Servicios como el Spa o las excursiones tienen capacidades limitadas determinadas por factores físicos como el número de camillas disponibles, la cantidad de terapeutas en servicio o la capacidad de las embarcaciones utilizadas. La ausencia de controles automatizados permitía situaciones de sobreventa donde se aceptaban más reservas de las que podían ser efectivamente atendidas, generando insatisfacción entre clientes que habían reservado servicios que luego no podían ser provistos en los horarios solicitados.

Finalmente, la carencia de información consolidada para la toma de decisiones representaba un obstáculo estratégico significativo. La gerencia del resort requería información actualizada sobre ocupación, ingresos por concepto, rentabilidad de servicios adicionales, comportamiento de compra de diferentes segmentos de clientes y múltiples indicadores adicionales que permiten la gestión estratégica del negocio. La dispersión de la información en múltiples sistemas y registros manuales dificultaba la generación de estos reportes, consumiendo recursos significativos en tareas de consolidación manual y, más importante aún, retrasando la disponibilidad de información crítica para decisiones que debían tomarse en ventanas temporales reducidas.

## **2.3. Objetivos del Sistema**

Frente a esta problemática multidimensional, el proyecto se planteó objetivos claros que guiaron el proceso de diseño e implementación. El objetivo principal consistió en desarrollar un sistema integral de gestión hotelera que centralizara toda la información operativa relevante, automatizara los procesos críticos del negocio, garantizara la integridad y consistencia de los datos, y proporcionara las bases para una gestión estratégica fundamentada en información confiable y oportuna.

Este objetivo general se descompuso en objetivos específicos que abordaban cada una de las problemáticas identificadas. En primer lugar, se buscó implementar mecanismos automatizados de validación que detectaran y bloquearan intentos de duplicación de reservas, registrando estos eventos en un sistema de alertas que permitiera tanto prevenir la consumación del error como analizar posteriormente los patrones de ocurrencia para implementar mejoras en las interfaces de usuario.

En segundo lugar, el sistema debía garantizar la trazabilidad completa de todas las transacciones, manteniendo registros históricos de los precios aplicados en cada operación. Esta trazabilidad no solo cumplía funciones de transparencia hacia el cliente y respaldo ante posibles disputas, sino que además generaba la información necesaria para análisis retrospectivos de rentabilidad y efectividad de estrategias comerciales.

El tercer objetivo específico correspondía a la optimización de la gestión del inventario de habitaciones mediante la implementación de un sistema robusto de estados que reflejara con precisión la disponibilidad real. El sistema debía facilitar la transición controlada entre estados, documentando cada cambio con información de auditoría que permitiera rastrear cuándo, quién y por qué una habitación había cambiado de estado.

En cuarto lugar, el sistema debía proporcionar flexibilidad para la implementación de estrategias de precios dinámicos mediante la gestión de temporadas y tarifas diferenciadas. Esta capacidad requería la definición de períodos temporales con sus respectivas tarifas por tipo de habitación, la aplicación automática de la tarifa correspondiente según la fecha de check-in seleccionada, y la preservación de la tarifa aplicada en cada transacción.

El quinto objetivo específico abordaba el control de cupos de servicios adicionales, requiriendo la implementación de validaciones que prevengan la sobreventa. Cada servicio debía tener definido un cupo diario máximo, y el sistema debía verificar la disponibilidad antes de aceptar nuevas contrataciones.

Finalmente, el sistema debía facilitar la generación de información consolidada para la gestión estratégica mediante la implementación de vistas y consultas que presentaran la información en formatos directamente utilizables para la toma de decisiones.

## **2.4. Alcance y Limitaciones**

La definición precisa del alcance del proyecto resultó fundamental para asegurar la factibilidad de su ejecución en los plazos establecidos y con los recursos disponibles. El alcance incluyó todos los procesos operativos centrales del negocio hotelero, abarcando la gestión completa del ciclo de vida de las reservas, el control de inventario de habitaciones, la administración de clientes con sus validaciones correspondientes, la gestión de temporadas y tarifas dinámicas, el control de servicios adicionales incluyendo la verificación de cupos, la facturación básica y el registro de pagos, el sistema de alertas operativas para auditoría y control, y la generación de reportes básicos de gestión.

Sin embargo, resultó igualmente importante definir con claridad lo que quedaba fuera del alcance de esta primera versión del sistema. El proyecto no incluyó la implementación de un sistema de check-in y check-out online, manteniendo estos procesos como actividades presenciales gestionadas por el personal de recepción. La integración con pasarelas de pago también quedó fuera del alcance, registrándose los pagos de manera manual en el sistema una vez que han sido procesados a través de los mecanismos actualmente establecidos por el resort.

Los sistemas de gestión de personal, nómina y control de inventario de insumos operativos se consideraron fuera del alcance por corresponder a dominios de información diferentes que justifican sistemas especializados independientes. Las funcionalidades avanzadas de Customer Relationship Management, incluyendo campañas de marketing, programas de fidelización y análisis predictivo de comportamiento de clientes, también quedaron fuera del alcance. Las herramientas de Business Intelligence, incluyendo dashboards analíticos interactivos, reportes ejecutivos avanzados y análisis multidimensional de datos, fueron consideradas fuera del alcance de esta primera versión. Finalmente, las aplicaciones móviles para huéspedes y las integraciones con sistemas externos como Online Travel Agencies y metabuscadores fueron consideradas fuera del alcance.

---

# **3. ANÁLISIS DE REQUERIMIENTOS**

## **3.1. Requerimientos Funcionales**

El análisis detallado de los procesos del negocio permitió identificar los requerimientos funcionales que el sistema debía satisfacer, organizados en grupos temáticos que reflejan los principales dominios de información y procesos del sistema.

El primer grupo de requerimientos corresponde a la gestión de clientes, donde el sistema debe proporcionar capacidades completas para registrar nuevos clientes capturando toda la información necesaria para su identificación y contacto. El registro incluye datos personales básicos como nombre y apellido, documento de identidad que debe ser único en el sistema para prevenir duplicaciones, dirección de correo electrónico que también debe ser única y debe cumplir con validaciones de formato que garanticen su validez, número telefónico para contacto, y fecha de nacimiento que será utilizada para validar que el cliente cumple con el requisito de mayoría de edad. Cada cliente tiene además un estado que puede ser activo o inactivo, permitiendo deshabilitar temporalmente clientes sin eliminar su información histórica.

Las validaciones implementadas sobre los datos de clientes resultan críticas para mantener la calidad de la información. La validación del formato del correo electrónico verifica que cumpla con patrones estándar, incluyendo la presencia de un único símbolo arroba, la existencia de un dominio y extensión válidos, la ausencia de caracteres especiales no permitidos, y longitudes mínimas y máximas apropiadas. La validación de mayoría de edad calcula la diferencia entre la fecha actual y la fecha de nacimiento registrada, rechazando registros de personas menores de dieciocho años.

El segundo grupo de requerimientos aborda la gestión de habitaciones, donde el sistema debe mantener información completa y actualizada sobre cada unidad de alojamiento del resort. Cada habitación se identifica mediante un número único visible para los huéspedes y el personal. La clasificación por tipo determina las características básicas de la habitación, su capacidad y servicios incluidos. La asignación de vista impacta en la percepción de valor por parte del cliente y justifica diferenciales de precio.

El control de estados operativos de las habitaciones representa un requerimiento crítico cuya correcta implementación previene múltiples problemas operativos. Una habitación puede encontrarse en estado disponible indicando que está lista para ser vendida, estado fuera de servicio cuando requiere mantenimiento temporal, estado inactiva para habitaciones que no están siendo ofrecidas por razones estratégicas, o estado ocupada cuando está siendo utilizada por un huésped. Las transiciones entre estos estados deben seguir reglas específicas del negocio y deben quedar documentadas mediante registros de auditoría.

El tercer grupo de requerimientos corresponde al sistema de tarifas dinámicas, uno de los componentes más estratégicos del sistema por su impacto directo en la rentabilidad del negocio. El modelo implementado se basa en la definición de temporadas, que son períodos temporales con características comerciales homogéneas. Las tarifas se definen asociando cada tipo de habitación con cada temporada, estableciendo el precio por noche aplicable durante ese período. Un aspecto fundamental es la trazabilidad de precios, donde el sistema almacena el precio específico en el registro de detalle de la reserva, garantizando que modificaciones posteriores no afecten retroactivamente reservas ya confirmadas.

El cuarto grupo de requerimientos aborda la gestión integral de reservas, el proceso central del negocio hotelero. Una reserva representa el compromiso del resort de proporcionar alojamiento y servicios a un cliente específico durante un período determinado. Cada reserva se asocia a un único cliente pero puede incluir múltiples habitaciones. El cálculo de totales considera tanto el hospedaje como los servicios adicionales contratados. El control de estados proporciona visibilidad sobre el ciclo de vida de cada reserva, transitando desde pendiente a confirmada, en curso, completada o cancelada.

El quinto grupo corresponde al control de servicios adicionales, componente crítico para la generación de ingresos complementarios. Cada servicio mantiene información sobre su costo operativo que permite calcular márgenes de rentabilidad, su precio de venta, y su cupo diario máximo que refleja las restricciones de capacidad. La contratación puede realizarse anticipadamente durante la reserva o durante la estadía.

El sexto grupo aborda la facturación y gestión de pagos. La emisión de facturas se realiza al momento del check-out, consolidando el alojamiento y todos los servicios adicionales consumidos. El diseño contempla también facturas para clientes walk-in sin reserva de alojamiento. La gestión de pagos reconoce diferentes tipos que reflejan momentos distintos del ciclo comercial, incluyendo seña, anticipo, saldo y consumos aislados.

El séptimo grupo corresponde al sistema de alertas, componente transversal que proporciona capacidades de auditoría y control de calidad. Las alertas se generan automáticamente cuando el sistema detecta situaciones que requieren atención, incluyendo repeticiones, errores, mantenimiento y advertencias.

## **3.2. Requerimientos No Funcionales**

Además de los requerimientos funcionales que especifican qué debe hacer el sistema, se identificaron requerimientos no funcionales que establecen cómo debe hacerlo, definiendo atributos de calidad críticos para el éxito del proyecto.

El primer requerimiento no funcional corresponde a la confiabilidad del sistema, entendida como su capacidad para mantener la integridad de los datos en todas las circunstancias. Esto se logró mediante la implementación rigurosa de constraints de integridad, la utilización de transacciones explícitas en todas las operaciones críticas, el manejo sistemático de excepciones, y la implementación de soft deletes que preservan información histórica.

El segundo requerimiento aborda la trazabilidad y auditoría. Todas las tablas incorporan campos que registran quién creó cada registro y cuándo, quién lo modificó y cuándo, y si fue eliminado, quién y cuándo. Esta información resulta invaluable para investigar problemas, cumplir con requerimientos de auditoría externa, y analizar patrones de uso.

El tercer requerimiento corresponde al desempeño, particularmente relevante en operaciones de consulta frecuente. La normalización del modelo contribuye a la eficiencia en actualizaciones, mientras que vistas materializadas y índices apropiados mitigan el impacto en consultas complejas.

El cuarto requerimiento aborda la usabilidad desde la perspectiva de los desarrolladores y administradores. La utilización de nombres descriptivos y consistentes, la documentación inline mediante comentarios, y la estructuración clara del código mejoran la mantenibilidad.

El quinto requerimiento corresponde a la escalabilidad, entendida como la capacidad del sistema para mantener su funcionalidad y desempeño a medida que crecen los volúmenes de datos. El uso de tipos de datos apropiados, campos identity para claves primarias, y una arquitectura modular facilitan el crecimiento futuro.

El sexto requerimiento aborda la seguridad de los datos. La separación de información sensible en tablas específicas permite la implementación de políticas de acceso granulares, mientras que la documentación de la estructura facilita el análisis de impacto de cambios.

---

# **4. DISEÑO CONCEPTUAL - MODELO ENTIDAD-RELACIÓN**

El diseño conceptual representa la primera etapa del proceso de modelado de datos, donde se identifican las entidades que conforman el dominio del problema, sus atributos característicos, y las relaciones que existen entre ellas. Este modelo se expresa mediante un Diagrama Entidad-Relación que proporciona una representación gráfica y formal de la estructura de información del sistema.

## **4.1. Identificación de Entidades**

El análisis del dominio del negocio hotelero permitió identificar catorce entidades principales que capturan toda la información relevante para la gestión del resort. La entidad Temporada representa los períodos del año con características comerciales homogéneas, permitiendo al resort adaptar su estrategia de precios a las fluctuaciones de demanda determinadas por factores climáticos, períodos vacacionales y eventos especiales.

La entidad Tipo de Habitación representa las categorías en que se clasifica el inventario de alojamiento, respondiendo a diferencias objetivas en términos de superficie, equipamiento y amenidades. El modelo contempla tres tipos principales: Estándar ofreciendo confort básico, Superior proporcionando espacios amplios y equipamiento premium, y Suite representando el segmento de lujo con áreas separadas y servicios diferenciados.

La entidad Tarifa materializa la matriz de precios que vincula tipos de habitación con temporadas. Esta es una entidad asociativa que permite implementar estrategias de pricing dinámico, donde el mismo tipo de habitación tiene precios significativamente diferentes según la temporada.

La entidad Vista representa las orientaciones o panorámicas que ofrecen las habitaciones, característica que impacta significativamente en la percepción de valor por parte de los clientes. Las vistas definidas incluyen Mar como producto premium, Jardín ofreciendo conexión con la naturaleza, e Interna con precios más accesibles.

La entidad Habitación representa las unidades físicas de alojamiento que constituyen el inventario vendible del resort. Cada habitación es única, se asocia a un tipo y a una vista, y mantiene un estado operativo que indica su disponibilidad actual entre Disponible, Fuera de Servicio, Inactiva y Ocupada.

La entidad Cliente representa las personas que contratan servicios del resort, registrándose con información personal completa y manteniendo un estado que permite habilitación o deshabilitación temporal sin pérdida de información histórica.

La entidad Reserva representa los compromisos del resort para proporcionar alojamiento durante un período determinado. Cada reserva se asocia a un único cliente pero puede incluir múltiples habitaciones, manteniendo fechas globales, un estado que refleja su posición en el ciclo de vida, y un total que consolida todos los costos asociados.

La entidad Detalle de Reserva descompone cada reserva en las habitaciones específicas incluidas, permitiendo que una reserva abarque múltiples unidades de alojamiento. Cada línea especifica la habitación, el precio por noche, las fechas específicas y la cantidad de noches.

La entidad Servicio Adicional representa el catálogo de servicios opcionales que complementan el alojamiento. Cada servicio mantiene su costo operativo para cálculo de márgenes, su precio de venta, y su cupo diario máximo que refleja restricciones de capacidad.

La entidad Consumo registra cada contratación de un servicio adicional, vinculando al cliente, a la reserva si existe, y al servicio contratado. Captura cantidad, precio unitario vigente, fecha del servicio y subtotal calculado, permitiendo registrar tanto consumos asociados a reservas como consumos de clientes walk-in.

La entidad Factura representa los comprobantes de venta emitidos por el resort. Cada factura se asocia a un cliente y opcionalmente a una reserva, manteniendo un número único, tipo de comprobante, concepto, importes desglosados, estado y fecha de emisión.

La entidad Detalle de Factura descompone cada factura en líneas individuales que especifican cada concepto cobrado, manteniendo referencias opcionales a los detalles de reserva o consumos que originaron cada cargo para proporcionar trazabilidad completa.

La entidad Pago registra cada transacción financiera realizada. Cada pago se asocia opcionalmente a una reserva y a una factura, permitiendo registrar señas antes de que exista factura y posteriormente vincular esos pagos cuando la factura se emite. Especifica tipo de pago, método utilizado, monto, estado, referencia, concepto y fecha.

La entidad Alerta registra eventos operativos significativos que requieren documentación. Cada alerta tiene un tipo entre Repetición, Error, Mantenimiento o Advertencia, una descripción detallada, y referencias opcionales a los objetos involucrados.

## **4.2. Definición de Atributos y Dominios**

Cada entidad se caracteriza por un conjunto de atributos que capturan las propiedades relevantes de sus instancias. La definición precisa de estos atributos, incluyendo sus dominios de valores posibles y restricciones, resulta fundamental para garantizar la calidad y consistencia de los datos.

Para la entidad Temporada, el identificador es un atributo numérico entero autogenerado que sirve como clave primaria. El nombre es una cadena de caracteres de hasta cincuenta caracteres que identifica la temporada concisamente. La descripción permite hasta doscientos cincuenta y cinco caracteres para documentar características y justificación. Las fechas de inicio y fin son atributos de tipo datetime que determinan el período de vigencia, con una restricción que garantiza que la fecha de fin sea posterior a la fecha de inicio mediante un constraint de verificación. Los atributos de auditoría incluyen el usuario que creó el registro con valor por defecto de SYSTEM_USER, la fecha y hora de creación con valor por defecto de GETDATE, el usuario que realizó la última modificación, la fecha y hora de esa modificación, el usuario que eliminó el registro si aplicara, y la fecha y hora de eliminación.

Para la entidad Tipo de Habitación, además del identificador numérico autogenerado, se definen el nombre con hasta cincuenta caracteres, la descripción con hasta doscientos cincuenta y cinco caracteres, y la capacidad como entero con una restricción que garantiza valores mayores a cero. Los atributos de auditoría siguen el mismo patrón que todas las entidades del sistema.

Para la entidad Tarifa, el identificador numérico se complementa con las claves foráneas que referencian al tipo de habitación y a la temporada, materializando la relación entre estas entidades. La descripción proporciona contexto sobre la tarifa específica. El precio por noche es un atributo decimal con precisión de diez dígitos totales y dos decimales, apropiado para valores monetarios, con una restricción que garantiza valores no negativos. Los atributos de auditoría completan la definición.

Para la entidad Vista, se define un identificador numérico autogenerado, un nombre de hasta cincuenta caracteres, y una descripción de hasta doscientos cincuenta y cinco caracteres. Los atributos de auditoría siguen el patrón estándar.

Para la entidad Habitación, el identificador numérico interno se complementa con el número de habitación definido como varchar de diez caracteres para permitir esquemas alfanuméricos, con una restricción de unicidad implementada mediante constraint unique. Las claves foráneas al tipo de habitación y a la vista materializan las relaciones correspondientes. El nombre proporciona identificación descriptiva con hasta cincuenta caracteres. La descripción permite hasta doscientos cincuenta y cinco caracteres. El piso es un entero con restricción de no negatividad. El estado operativo es varchar de veinte caracteres con valores restringidos mediante constraint check que verifica que el valor esté entre Disponible, Fuera de Servicio, Inactiva y Ocupada, con valor por defecto de Disponible. Los atributos de auditoría completan la entidad.

Para la entidad Cliente, el identificador numérico se complementa con nombre y apellido como varchar de cincuenta caracteres. El documento de identidad es varchar de veinte caracteres con restricción de unicidad implementada mediante constraint unique. El correo electrónico es varchar de cien caracteres también con restricción de unicidad, y adicionalmente se valida mediante una expresión compleja que verifica el formato apropiado. Esta validación incluye múltiples condiciones concatenadas mediante operadores lógicos que verifican la presencia de un único símbolo arroba, la existencia de caracteres antes y después del arroba, la presencia de al menos un punto después del arroba, la ausencia de espacios, la ausencia de puntos consecutivos, la ausencia de combinaciones inválidas como punto-arroba o arroba-punto, y longitudes mínimas y máximas apropiadas. El teléfono es varchar de veinte caracteres. El estado toma valores Activo o Inactivo mediante constraint check, con valor por defecto de Activo. La fecha de nacimiento es datetime sobre el cual se implementa una restricción mediante constraint check que calcula la diferencia en años entre la fecha actual y la fecha de nacimiento, rechazando registros donde esta diferencia sea menor a dieciocho años. Los atributos de auditoría completan la definición.

Para la entidad Reserva, el identificador numérico se complementa con la clave foránea al cliente implementada mediante foreign key. El estado de reserva es varchar de veinte caracteres tomando valores Pendiente, Confirmada, En Curso, Completada o Cancelada mediante constraint check, con valor por defecto de Pendiente. El total es decimal con precisión de diez dígitos y dos decimales, con restricción de no negatividad mediante check constraint. Las fechas de check-in y check-out son datetime con una restricción check que garantiza que check-out sea posterior a check-in. Los atributos de auditoría siguen el patrón estándar.

Para la entidad Detalle de Reserva, el identificador numérico se complementa con claves foráneas a la reserva y a la habitación implementadas mediante foreign key constraints. El precio por noche es decimal con precisión de diez dígitos y dos decimales y restricción de no negatividad, capturando el precio vigente al momento de la reserva para garantizar trazabilidad. Las fechas de check-in y check-out específicas del detalle son datetime con restricción check de orden temporal. La cantidad de noches es entero con restricción check de positividad. Los atributos de auditoría completan la entidad.

Para la entidad Servicio Adicional, el identificador se complementa con nombre de hasta cincuenta caracteres y descripción de hasta doscientos cincuenta y cinco caracteres. El costo y el precio son decimales con precisión de diez dígitos y dos decimales, ambos con restricciones check de no negatividad. El cupo diario máximo es entero con restricción check de no negatividad. Los atributos de auditoría siguen el patrón estándar.

Para la entidad Consumo, el identificador se complementa con claves foráneas opcionales implementadas como nullable al cliente y a la reserva, y una clave foránea obligatoria al servicio adicional. La cantidad es entero con restricción check de positividad. El precio unitario es decimal con precisión de diez dígitos y dos decimales y restricción check de no negatividad, capturando el precio vigente para trazabilidad. La fecha del servicio es datetime. El subtotal es decimal con precisión de diez dígitos y dos decimales y restricción check de no negatividad. Una restricción check adicional garantiza que al menos una de las referencias a cliente o reserva esté presente mediante una condición que verifica que id_cliente no sea nulo o id_reserva no sea nulo. Los atributos de auditoría completan la definición.

Para la entidad Factura, el identificador se complementa con una clave foránea obligatoria al cliente y una clave foránea nullable opcional a la reserva, permitiendo facturas para clientes walk-in sin reserva. El número de factura es varchar de cincuenta caracteres con restricción unique y constraint not null. El tipo de comprobante es varchar de veinte caracteres tomando valores Factura, Boleta o Ticket mediante constraint check. El concepto es varchar de doscientos cincuenta y cinco caracteres. Los importes de subtotal, impuestos y total son decimales con precisión de diez dígitos y dos decimales, todos con restricciones check de no negatividad. El estado es varchar de veinte caracteres tomando valores Emitida o Anulada mediante constraint check. La fecha de emisión es datetime con valor por defecto de GETDATE. Los atributos de auditoría completan la entidad.

Para la entidad Detalle de Factura, el identificador se complementa con la clave foránea a la factura. El concepto es varchar de doscientos cincuenta y cinco caracteres. La cantidad es entero con restricción check de positividad. El precio unitario y el subtotal son decimales con precisión de diez dígitos y dos decimales con restricciones check de no negatividad. Las claves foráneas opcionales nullable al detalle de reserva y al consumo proporcionan trazabilidad. Los atributos de auditoría siguen el patrón estándar.

Para la entidad Pago, el identificador se complementa con claves foráneas nullable opcionales a la reserva y a la factura. El tipo de pago es varchar de veinte caracteres tomando valores Seña, Anticipo, Saldo o Consumo mediante constraint check. El método de pago es varchar de veinte caracteres tomando valores Tarjeta_Crédito, Tarjeta_Débito, Efectivo o Transferencia mediante constraint check. El monto es decimal con precisión de diez dígitos y dos decimales con restricción check de positividad, requiriendo valores mayores a cero. El estado es varchar de veinte caracteres tomando valores Aprobado, Rechazado o Pendiente mediante constraint check. La referencia es varchar de cien caracteres. El concepto es varchar de doscientos cincuenta y cinco caracteres. La fecha de pago es datetime con valor por defecto de GETDATE. Una restricción check garantiza que al menos una de las referencias a reserva o factura esté presente mediante condición que verifica que id_reserva no sea nulo o id_factura no sea nulo. Los atributos de auditoría completan la definición.

Para la entidad Alerta, el identificador se complementa con un tipo que es varchar de veinte caracteres tomando valores Repetición, Error, Mantenimiento o Advertencia mediante constraint check. La descripción es varchar de quinientos caracteres documentando el evento. Las claves foráneas nullable opcionales a cliente, reserva y habitación permiten vincular la alerta con los objetos involucrados. Los atributos de auditoría siguen el patrón estándar del sistema.

## **4.3. Identificación de Relaciones y Cardinalidades**

Las relaciones entre entidades capturan las asociaciones significativas que existen en el dominio del negocio. La especificación precisa de las cardinalidades resulta fundamental para garantizar que el modelo refleje correctamente las reglas del negocio.

La relación entre Tipo de Habitación y Tarifa tiene cardinalidad uno a muchos, donde un tipo de habitación puede tener múltiples tarifas definidas correspondientes a diferentes temporadas, mientras que cada tarifa se refiere a exactamente un tipo de habitación. Esta relación se materializa mediante una clave foránea en Tarifa que referencia la clave primaria de Tipo de Habitación, con restricción de integridad referencial que garantiza que solo pueden existir tarifas para tipos de habitación válidos y previene la eliminación de tipos de habitación que tienen tarifas asociadas.

La relación entre Temporada y Tarifa también tiene cardinalidad uno a muchos, donde una temporada tiene múltiples tarifas definidas correspondientes a diferentes tipos de habitación, mientras que cada tarifa se refiere a exactamente una temporada. La materialización mediante clave foránea en Tarifa garantiza integridad referencial.

La relación entre Tipo de Habitación y Habitación es uno a muchos, donde un tipo agrupa múltiples habitaciones que comparten características, mientras que cada habitación pertenece a exactamente un tipo. La clave foránea en Habitación materializa esta relación con las restricciones de integridad correspondientes.

La relación entre Vista y Habitación es uno a muchos, donde una vista puede ser la orientación de múltiples habitaciones, mientras que cada habitación tiene exactamente una vista asignada. La materialización mediante clave foránea garantiza consistencia.

La relación entre Cliente y Reserva es uno a muchos, donde un cliente puede realizar múltiples reservas a lo largo del tiempo, mientras que cada reserva pertenece a exactamente un cliente. La clave foránea en Reserva materializa esta relación, garantizando que no pueden existir reservas sin cliente asociado y controlando las operaciones de eliminación para preservar integridad histórica.

La relación entre Reserva y Detalle de Reserva es uno a muchos y además es una relación de composición, donde una reserva puede incluir múltiples habitaciones representadas por detalles, mientras que cada detalle pertenece a exactamente una reserva y no tiene existencia independiente. La clave foránea en Detalle de Reserva materializa esta relación con opciones de cascada que garantizan que la eliminación de una reserva elimina automáticamente todos sus detalles.

La relación entre Habitación y Detalle de Reserva es uno a muchos, donde una habitación puede aparecer en múltiples detalles a lo largo del tiempo correspondiendo a diferentes períodos y clientes, mientras que cada detalle se refiere a exactamente una habitación. La clave foránea materializa esta relación con restricciones que previenen reservar habitaciones inexistentes.

La relación entre Cliente y Consumo es uno a muchos con participación opcional del lado de Consumo, donde un cliente puede tener múltiples consumos registrados, mientras que cada consumo puede asociarse opcionalmente a un cliente. Esta opcionalidad mediante clave foránea nullable permite registrar consumos sin cliente específico en situaciones particulares, aunque la restricción check del modelo garantiza que si no hay cliente debe haber reserva.

La relación entre Reserva y Consumo es uno a muchos con participación opcional del lado de Consumo, donde una reserva puede tener múltiples consumos asociados, mientras que cada consumo puede asociarse opcionalmente a una reserva. La clave foránea nullable permite consumos sin reserva específica, típicamente correspondientes a clientes walk-in.

La relación entre Servicio Adicional y Consumo es uno a muchos, donde un servicio puede ser consumido múltiples veces por diferentes clientes en diferentes momentos, mientras que cada consumo se refiere a exactamente un servicio adicional. La clave foránea obligatoria garantiza que todos los consumos tienen servicio asociado.

La relación entre Cliente y Factura es uno a muchos, donde un cliente puede tener múltiples facturas emitidas a lo largo del tiempo, mientras que cada factura pertenece a exactamente un cliente. La clave foránea obligatoria en Factura materializa esta relación, reflejando que todas las facturas deben tener un responsable identificado.

La relación entre Reserva y Factura es uno a uno con participación opcional del lado de Factura, donde una reserva típicamente tiene una factura asociada emitida al check-out, mientras que cada factura puede asociarse opcionalmente a una reserva. La clave foránea nullable en Factura permite facturas para clientes walk-in sin reserva de alojamiento.

La relación entre Factura y Detalle de Factura es uno a muchos y otra relación de composición, donde una factura puede incluir múltiples líneas de detalle, mientras que cada detalle pertenece a exactamente una factura y no tiene existencia independiente. La clave foránea con opciones de cascada garantiza eliminación coordinada.

La relación entre Detalle de Reserva y Detalle de Factura es uno a uno con participación opcional del lado de Detalle de Factura, donde un detalle de reserva puede ser referenciado por una línea de factura para trazabilidad, mientras que cada detalle de factura puede referenciar opcionalmente a un detalle de reserva. La clave foránea nullable permite líneas de factura que no corresponden a hospedaje.

La relación entre Consumo y Detalle de Factura es uno a uno con participación opcional del lado de Detalle de Factura, donde un consumo puede ser referenciado por una línea de factura para trazabilidad, mientras que cada detalle de factura puede referenciar opcionalmente a un consumo. La clave foránea nullable permite líneas de factura que no corresponden a servicios adicionales.

La relación entre Reserva y Pago es uno a muchos con participación opcional del lado de Pago, donde una reserva puede tener múltiples pagos asociados correspondientes a seña, anticipos y saldo, mientras que cada pago puede asociarse opcionalmente a una reserva. La clave foránea nullable permite pagos de clientes walk-in sin reserva.

La relación entre Factura y Pago es uno a muchos con participación opcional del lado de Pago, donde una factura puede tener múltiples pagos asociados, mientras que cada pago puede asociarse opcionalmente a una factura. La clave foránea nullable permite registrar pagos de seña antes de que exista factura, vinculándose posteriormente cuando la factura se emite.

Las relaciones de Alerta con Cliente, Reserva y Habitación son todas uno a muchos con participación opcional del lado de Alerta. Una alerta puede referenciar opcionalmente a un cliente, una reserva o una habitación involucrados en el evento documentado. Las claves foráneas nullable permiten alertas genéricas no asociadas a objetos específicos. Un cliente, reserva o habitación pueden tener múltiples alertas asociadas a lo largo del tiempo.

---

# **5. DISEÑO LÓGICO - MODELO RELACIONAL**

El diseño lógico transforma el modelo conceptual expresado mediante el Diagrama Entidad-Relación en un modelo relacional que puede ser implementado en un Sistema de Gestión de Bases de Datos Relacionales. Este proceso implica la conversión de entidades en tablas, atributos en columnas, y relaciones en claves foráneas, respetando las restricciones de integridad identificadas.

## **5.1. Transformación del Modelo Conceptual**

La transformación del modelo conceptual al modelo relacional se realizó siguiendo las reglas estándar de conversión. Cada entidad identificada se convirtió en una tabla del modelo relacional. El identificador único de cada entidad se convirtió en la clave primaria de la tabla correspondiente, implementada mediante constraint primary key que garantiza unicidad y no nulidad automáticamente. Los atributos simples de cada entidad se convirtieron en columnas de la tabla, especificándose el tipo de dato apropiado según el dominio del atributo.

Las relaciones se materializaron mediante claves foráneas en las tablas correspondientes. Para relaciones uno a muchos, la clave foránea se ubicó en la tabla del lado muchos, referenciando la clave primaria de la tabla del lado uno. Esta materialización se implementó mediante constraint foreign key que garantiza integridad referencial, previniendo la inserción de registros con referencias a entidades inexistentes y controlando las operaciones de actualización y eliminación mediante opciones de cascada apropiadas.

Para las relaciones muchos a muchos identificadas, se crearon tablas intermedias que materializan estas relaciones. La tabla Tarifa, por ejemplo, materializa la relación muchos a muchos entre Tipo de Habitación y Temporada, donde un tipo puede tener múltiples temporadas y una temporada puede aplicar a múltiples tipos. La clave primaria de la tabla intermedia se compone típicamente de las claves foráneas de ambas entidades relacionadas, aunque en este caso se optó por una clave primaria autogenerada independiente para facilitar referencias futuras.

Las relaciones de composición, donde una entidad no tiene existencia independiente de otra, se implementaron con opciones de cascada en las restricciones de clave foránea. La relación entre Reserva y Detalle de Reserva, por ejemplo, se implementó con opciones que garantizan que la eliminación de una reserva elimina automáticamente todos sus detalles, manteniendo la consistencia del modelo.

## **5.2. Especificación de Tablas y Restricciones**

El modelo relacional resultante comprende catorce tablas principales que materializan las entidades identificadas, más las tablas de soporte para catálogos y configuración. Cada tabla se especificó completamente incluyendo todas sus columnas con tipos de datos apropiados, restricciones de integridad, valores por defecto, y opciones de generación automática de identificadores.

La tabla temporada se especificó con una columna id_temporada de tipo integer con propiedad identity que genera valores autoincrementales comenzando en uno con incrementos de uno. Las columnas nombre y descripcion son de tipo varchar con longitudes de cincuenta y doscientos cincuenta y cinco caracteres respectivamente. Las columnas fecha_inicio y fecha_fin son de tipo datetime. La clave primaria se define sobre id_temporada. Un constraint check verifica que fecha_fin sea mayor que fecha_inicio mediante una expresión booleana. Las columnas de auditoría incluyen creado_por como varchar de cien caracteres con valor por defecto de SYSTEM_USER, fecha_creacion como datetime con valor por defecto de GETDATE, modificado_por como varchar de cien caracteres nullable, fecha_modificacion como datetime nullable, eliminado_por como varchar de cien caracteres nullable, y fecha_eliminacion como datetime nullable.

La tabla tipo_habitacion sigue un patrón similar con id_tipo_habitacion integer identity como clave primaria, nombre y descripcion como varchar de cincuenta y doscientos cincuenta y cinco caracteres, capacidad como integer con constraint check que verifica valores mayores a cero, y las columnas estándar de auditoría.

La tabla tarifa incluye id_tarifa integer identity como clave primaria, id_tipo_habitacion integer como clave foránea a tipo_habitacion, id_temporada integer como clave foránea a temporada, descripcion varchar de doscientos cincuenta y cinco caracteres, precio_noche decimal con precisión de diez comas dos con constraint check de no negatividad, y las columnas de auditoría. Las claves foráneas se implementan mediante constraint foreign key con nombres descriptivos que facilitan la identificación en mensajes de error.

La tabla vista se especifica con id_vista integer identity como clave primaria, nombre varchar de cincuenta caracteres, descripcion varchar de doscientos cincuenta y cinco caracteres, y las columnas de auditoría estándar.

La tabla habitacion incluye id_habitacion integer identity como clave primaria, numero_habitacion varchar de diez caracteres con constraint unique que garantiza unicidad, id_tipo_habitacion integer como clave foránea, id_vista integer como clave foránea, nombre varchar de cincuenta caracteres, descripcion varchar de doscientos cincuenta y cinco caracteres, piso integer con constraint check de no negatividad, estado_operativo varchar de veinte caracteres con valor por defecto de Disponible y constraint check que verifica que el valor esté en el conjunto permitido, y las columnas de auditoría. Las claves foráneas se definen con nombres descriptivos y opciones apropiadas de integridad referencial.

La tabla cliente se especifica con id_cliente integer identity como clave primaria, nombre y apellido varchar de cincuenta caracteres, dni varchar de veinte caracteres con constraint unique, email varchar de cien caracteres con constraint unique y un constraint check complejo que valida el formato mediante múltiples condiciones concatenadas con operadores lógicos, telefono varchar de veinte caracteres, estado varchar de veinte caracteres con valor por defecto de Activo y constraint check que verifica valores en el conjunto permitido, fecha_nacimiento datetime con constraint check que calcula la edad y rechaza valores menores a dieciocho años, y las columnas de auditoría estándar.

La tabla reserva incluye id_reserva integer identity como clave primaria, id_cliente integer como clave foránea a cliente, estado_reserva varchar de veinte caracteres con valor por defecto de Pendiente y constraint check sobre valores permitidos, total decimal diez comas dos con constraint check de no negatividad, fecha_checkin y fecha_checkout datetime con constraint check que verifica que checkout sea posterior a checkin, y las columnas de auditoría. La clave foránea a cliente se implementa con opciones que preservan integridad histórica.

La tabla detalle_reserva se especifica con id_detalle_reserva integer identity como clave primaria, id_reserva integer como clave foránea, id_habitacion integer como clave foránea, precio_noche decimal diez comas dos con constraint check de no negatividad, fecha_checkin y fecha_checkout datetime con constraint check de orden temporal, cant_noches integer con constraint check de positividad, y las columnas de auditoría. Las claves foráneas se definen con opciones de cascada apropiadas considerando que esta es una tabla de detalle dependiente.

La tabla servicio_adicional incluye id_servicio_adicional integer identity como clave primaria, nombre varchar de cincuenta caracteres, descripcion varchar de doscientos cincuenta y cinco caracteres, costo y precio decimal diez comas dos ambos con constraints check de no negatividad, cupo_diario_max integer con constraint check de no negatividad, y las columnas de auditoría estándar.

La tabla consumo se especifica con id_consumo integer identity como clave primaria, id_cliente integer nullable como clave foránea opcional, id_reserva integer nullable como clave foránea opcional, id_servicio_adicional integer como clave foránea obligatoria, cantidad integer con constraint check de positividad, precio_unitario decimal diez comas dos con constraint check de no negatividad, fecha_servicio datetime, subtotal decimal diez comas dos con constraint check de no negatividad, y las columnas de auditoría. Adicionalmente se define un constraint check que garantiza que al menos uno de id_cliente o id_reserva no sea nulo mediante una expresión que verifica esta condición disyuntiva.

La tabla factura incluye id_factura integer identity como clave primaria, id_cliente integer como clave foránea obligatoria, id_reserva integer nullable como clave foránea opcional, numero_factura varchar de cincuenta caracteres con constraint unique y not null, tipo_comprobante varchar de veinte caracteres con constraint check sobre valores permitidos, concepto varchar de doscientos cincuenta y cinco caracteres, subtotal impuestos y total decimal diez comas dos con constraints check de no negatividad, estado varchar de veinte caracteres con constraint check sobre valores permitidos, fecha_emision datetime con valor por defecto de GETDATE, y las columnas de auditoría. La combinación de clave foránea obligatoria a cliente y opcional a reserva permite tanto facturas asociadas a reservas como facturas para clientes walk-in.

La tabla detalle_factura se especifica con id_detalle_factura integer identity como clave primaria, id_factura integer como clave foránea, concepto varchar de doscientos cincuenta y cinco caracteres, cantidad integer con constraint check de positividad, precio_unitario y subtotal decimal diez comas dos con constraints check de no negatividad, id_detalle_reserva integer nullable como clave foránea opcional, id_consumo integer nullable como clave foránea opcional, y las columnas de auditoría. Las claves foráneas opcionales a detalle_reserva y consumo proporcionan trazabilidad sin forzar estas referencias.

La tabla pago incluye id_pago integer identity como clave primaria, id_reserva integer nullable como clave foránea opcional, id_factura integer nullable como clave foránea opcional, tipo_pago varchar de veinte caracteres con constraint check sobre valores permitidos, metodo_pago varchar de veinte caracteres con constraint check sobre valores permitidos, monto decimal diez comas dos con constraint check que requiere valores mayores a cero, estado varchar de veinte caracteres con constraint check sobre valores permitidos, referencia varchar de cien caracteres, concepto varchar de doscientos cincuenta y cinco caracteres, fecha_pago datetime con valor por defecto de GETDATE, y las columnas de auditoría. Un constraint check adicional garantiza que al menos uno de id_reserva o id_factura no sea nulo mediante expresión lógica apropiada.

La tabla alerta se especifica con id_alerta integer identity como clave primaria, tipo varchar de veinte caracteres con constraint check sobre valores permitidos, descripcion varchar de quinientos caracteres, id_cliente integer nullable como clave foránea opcional, id_reserva integer nullable como clave foránea opcional, id_habitacion integer nullable como clave foránea opcional, y las columnas de auditoría. Las claves foráneas opcionales permiten asociar alertas a los objetos involucrados cuando aplica.

## **5.3. Índices y Optimización**

Además de las restricciones de integridad, el modelo relacional incluye consideraciones de desempeño mediante la definición de índices apropiados. Si bien las claves primarias generan automáticamente índices únicos clustered que optimizan búsquedas por identificador, se identificaron columnas adicionales que se utilizan frecuentemente en condiciones de búsqueda y que se beneficiarían de índices secundarios.

La columna dni en la tabla cliente, además de su restricción de unicidad, se beneficia de un índice que optimiza búsquedas de clientes por documento. La columna email también se indexa para optimizar validaciones de duplicidad y búsquedas por correo electrónico. La columna numero_habitacion en la tabla habitacion requiere índice para optimizar búsquedas por número visible de habitación. La columna numero_factura en la tabla factura se indexa para optimizar búsquedas de facturas por su número de comprobante.

Las claves foráneas, que se utilizan intensivamente en operaciones de join, también se benefician de índices. Si bien algunos sistemas de gestión de bases de datos crean automáticamente índices sobre claves foráneas, la especificación explícita garantiza este comportamiento. Las columnas id_cliente en las tablas reserva, factura y alerta, id_reserva en las tablas detalle_reserva, consumo, factura y pago, id_habitacion en detalle_reserva, id_servicio_adicional en consumo, y id_factura en detalle_factura y pago, todas se indexan para optimizar joins frecuentes.

Las columnas que aparecen en condiciones de filtrado frecuentes también se consideran candidatas para indexación. La columna estado_reserva en reserva, estado_operativo en habitacion, y estado en factura y pago se utilizan frecuentemente en cláusulas where de consultas que buscan registros en estados específicos, justificando índices no únicos sobre estas columnas.

Las columnas de fecha que se utilizan en rangos de búsqueda también se consideran para indexación. Las columnas fecha_checkin y fecha_checkout en reserva y detalle_reserva, fecha_servicio en consumo, fecha_emision en factura, y fecha_pago en pago se utilizan en consultas que filtran por períodos temporales, beneficiándose de índices que optimizan estas operaciones de rango.

---

# **6. PROCESO DE NORMALIZACIÓN**

La normalización es el proceso de organizar los datos en una base de datos relacional para minimizar la redundancia y las dependencias, mejorando la integridad de los datos y facilitando su mantenimiento. El modelo desarrollado para el Resort Bahía Serena se diseñó desde el inicio considerando los principios de normalización, alcanzando la tercera forma normal en todas sus tablas.

## **6.1. Primera Forma Normal**

La primera forma normal requiere que todos los atributos de una tabla contengan valores atómicos, es decir, valores indivisibles que no pueden descomponerse en componentes más pequeños con significado propio, y que no existan grupos repetitivos de atributos. Todas las tablas del modelo satisfacen esta forma normal desde su concepción inicial.

En la tabla cliente, por ejemplo, se mantienen nombre y apellido como atributos separados en lugar de un único atributo nombre_completo, permitiendo operaciones independientes sobre cada componente y facilitando búsquedas y ordenamientos específicos. La dirección de correo electrónico se mantiene como un único campo atómico dado que, si bien técnicamente podría descomponerse en usuario, dominio y extensión, estas componentes no tienen significado operacional independiente en el contexto del negocio hotelero.

En la tabla habitacion, el número de habitación se mantiene como un único atributo a pesar de que algunos esquemas de numeración podrían codificar información como el piso o el ala del edificio. Esta decisión responde a que el número de habitación funciona primordialmente como identificador visible completo, y cualquier información adicional como el piso se mantiene explícitamente en atributos separados.

El modelo evita completamente grupos repetitivos de atributos. En lugar de mantener en la tabla reserva múltiples columnas como habitacion1, habitacion2, habitacion3 para casos donde una reserva incluye múltiples habitaciones, se utiliza la tabla detalle_reserva que permite un número variable de habitaciones mediante registros independientes. Esta estructura no solo satisface la primera forma normal sino que además proporciona flexibilidad para reservas con cualquier cantidad de habitaciones sin desperdiciar espacio en almacenamiento.

Similarmente, en lugar de mantener en la tabla reserva múltiples columnas para servicios adicionales, se utiliza la tabla consumo que permite registrar cualquier cantidad de servicios contratados mediante registros independientes. Esta estructura facilita además la extensión del catálogo de servicios sin requerir modificaciones estructurales en las tablas existentes.

## **6.2. Segunda Forma Normal**

La segunda forma normal requiere que la tabla esté en primera forma normal y además que todos los atributos no clave dependan completamente de la clave primaria completa, no solo de parte de ella. Esta forma normal se aplica principalmente a tablas cuya clave primaria es compuesta por múltiples columnas.

En el modelo desarrollado, la mayoría de las tablas utilizan claves primarias simples autogeneradas mediante identity, lo que automáticamente satisface la segunda forma normal dado que no puede existir dependencia parcial cuando la clave primaria consta de una única columna. Sin embargo, es instructivo considerar qué sucedería si se hubieran utilizado claves primarias compuestas en ciertas tablas.

Considérese la tabla detalle_reserva. Si se hubiera optado por una clave primaria compuesta por id_reserva e id_habitacion, estaría implícitamente asumiendo que una reserva no puede incluir la misma habitación múltiples veces, lo cual podría ser una restricción válida del negocio. En ese escenario, los atributos como precio_noche, fecha_checkin, fecha_checkout y cant_noches dependen de la combinación completa de id_reserva e id_habitacion, no solo de uno de ellos. El precio_noche no depende únicamente de la habitación porque puede variar según la temporada de la reserva. Las fechas no dependen únicamente de la reserva porque diferentes habitaciones dentro de la misma reserva podrían tener períodos diferentes. Por lo tanto, incluso con clave primaria compuesta, la tabla satisfaría la segunda forma normal. Sin embargo, la decisión de utilizar una clave primaria simple autogenerada elimina cualquier ambigüedad y facilita referencias desde otras tablas.

La tabla consumo presenta una situación similar. Si se hubiera utilizado una clave primaria compuesta por id_reserva, id_servicio_adicional y fecha_servicio, los atributos como cantidad, precio_unitario y subtotal dependen de esta combinación completa, no de componentes individuales. La cantidad no depende únicamente del servicio porque el mismo servicio puede contratarse múltiples veces en diferentes cantidades. El precio_unitario no depende únicamente del servicio porque puede variar en el tiempo. Nuevamente, la utilización de clave primaria simple autogenerada simplifica el modelo sin comprometer su normalización.

La tabla tarifa, que materializa la relación muchos a muchos entre tipo_habitacion y temporada, podría lógicamente utilizar una clave primaria compuesta por id_tipo_habitacion e id_temporada, asumiendo que existe una única tarifa por cada combinación. En ese caso, los atributos descripcion y precio_noche dependerían de la combinación completa, no de componentes individuales. El precio no depende únicamente del tipo de habitación porque varía según la temporada, ni únicamente de la temporada porque diferentes tipos tienen diferentes precios en la misma temporada. La decisión de utilizar id_tarifa autogenerado como clave primaria, si bien técnicamente permite la existencia de múltiples tarifas para la misma combinación de tipo y temporada, simplifica el modelo y facilita extensiones futuras como la gestión de historial de cambios de precios.

## **6.3. Tercera Forma Normal**

La tercera forma normal requiere que la tabla esté en segunda forma normal y además que no existan dependencias transitivas, es decir, que ningún atributo no clave dependa de otro atributo no clave. Todos los atributos no clave deben depender directamente de la clave primaria, no indirectamente a través de otros atributos.

El análisis de dependencias transitivas en el modelo revela que se han eliminado sistemáticamente mediante la separación apropiada en tablas normalizadas. Considérese la tabla habitacion. Originalmente, se podría haber considerado incluir directamente en esta tabla atributos como capacidad que en realidad dependen del tipo de habitación. Una habitación de tipo Suite tiene capacidad de seis personas no por características individuales de esa habitación específica, sino porque todas las Suites tienen esa capacidad. Incluir el atributo capacidad directamente en habitacion crearía una dependencia transitiva: capacidad depende de id_tipo_habitacion, que a su vez depende de id_habitacion. Esta dependencia transitiva se eliminó manteniendo capacidad en la tabla tipo_habitacion, donde depende directamente de la clave primaria de esa tabla.

Similarmente, en la tabla detalle_reserva se podría haber considerado incluir información sobre el tipo de habitación o su vista. Sin embargo, estos atributos dependerían de id_habitacion, no directamente de id_detalle_reserva, creando dependencias transitivas. El modelo mantiene esta información en la tabla habitacion, donde depende directamente de su clave primaria, y las consultas que requieren esta información la obtienen mediante joins apropiados.

La tabla consumo presenta una situación interesante respecto al precio_unitario. Este atributo podría considerarse transitivamente dependiente de id_servicio_adicional si asumimos que el precio de un servicio es fijo. Sin embargo, la inclusión de precio_unitario en consumo capturando el precio vigente al momento de la contratación no viola la tercera forma normal porque este atributo no depende del servicio en sí, sino del servicio en un momento temporal específico. Es un atributo de trazabilidad que captura un valor histórico que puede diferir del precio actual del servicio, por lo tanto depende directamente de la clave primaria de consumo, no transitivamente a través del servicio.

Igual razonamiento se aplica al precio_noche en detalle_reserva. Aunque existe una relación con la tabla tarifa que define precios por tipo de habitación y temporada, el precio_noche en detalle_reserva no es transitivamente dependiente porque captura el precio específico aplicado a esa reserva particular en ese momento específico, el cual podría diferir del precio actual en tarifa debido a promociones, descuentos especiales o simplemente cambios en las tarifas base después de que la reserva fue creada.

La tabla factura mantiene los importes de subtotal, impuestos y total como atributos directos, lo cual podría cuestionarse dado que el total podría calcularse sumando subtotal e impuestos. Sin embargo, estos no constituyen una dependencia transitiva sino atributos redundantes calculados que se mantienen por razones de desempeño y auditabilidad. La redundancia controlada en este caso específico no viola la normalización en el sentido estricto porque todos estos atributos representan propiedades directas de la factura, no dependencias a través de otros atributos. Además, la inclusión de estos valores calculados en la tabla facilita la detección de inconsistencias que podrían surgir de errores en la aplicación o manipulación manual de datos.

## **6.4. Formas Normales Superiores**

Más allá de la tercera forma normal, existen formas normales adicionales como la forma normal de Boyce-Codd, la cuarta forma normal y la quinta forma normal, que abordan situaciones específicas de dependencias más complejas. El análisis del modelo desarrollado sugiere que se satisfacen también estas formas normales superiores en la medida aplicable.

La forma normal de Boyce-Codd requiere que para toda dependencia funcional no trivial, el lado izquierdo sea una superclave. En el modelo desarrollado, dado que se utilizan claves primarias simples autogeneradas y que todos los atributos no clave dependen directamente de estas claves primarias, la forma normal de Boyce-Codd se satisface automáticamente. No existen situaciones donde un atributo no clave determine a otro atributo no clave, lo cual podría violar esta forma normal.

La cuarta forma normal aborda dependencias multivaluadas, requiriendo que no existan dependencias multivaluadas no triviales donde no estén involucradas claves candidatas. El modelo desarrollado evita dependencias multivaluadas mediante la separación apropiada de conceptos en tablas independientes. Por ejemplo, si una reserva pudiera asociarse tanto con múltiples habitaciones como con múltiples servicios adicionales, y estos fueran independientes entre sí, podría existir una dependencia multivaluada. Sin embargo, el modelo mantiene habitaciones en detalle_reserva y servicios en consumo como tablas separadas, cada una con su propia relación independiente con reserva, eliminando dependencias multivaluadas.

La quinta forma normal aborda dependencias de join, requiriendo que no sea posible descomponer la tabla en tablas más pequeñas sin pérdida de información. El modelo desarrollado satisface esta forma normal porque cada tabla representa un concepto cohesivo único que no puede descomponerse significativamente. La tabla detalle_reserva, por ejemplo, representa la asociación específica entre una reserva y una habitación con sus atributos temporales y financieros correspondientes. Cualquier intento de descomponerla resultaría en pérdida de información o en la necesidad de recomponer esta información mediante joins complejos sin beneficio aparente.

---

# **7. IMPLEMENTACIÓN FÍSICA - DEFINICIÓN DE DATOS**

La implementación física del modelo relacional se realizó mediante scripts de lenguaje de definición de datos (DDL) de Transact-SQL ejecutados sobre Microsoft SQL Server. Esta implementación traduce el diseño lógico en estructuras físicas concretas en el sistema de gestión de bases de datos, especificando tipos de datos precisos, restricciones de integridad, índices, y valores por defecto.

## **7.1. Estrategia de Implementación**

La estrategia de implementación siguió un orden específico que respeta las dependencias entre tablas. Las tablas sin dependencias externas se crearon primero, seguidas por tablas que referencian a estas mediante claves foráneas, garantizando que todas las referencias sean válidas en el momento de su definición.

El script de implementación comienza con la sentencia USE master que asegura que las operaciones posteriores se ejecuten en el contexto de la base de datos maestra. En un escenario de producción, se crearía primero la base de datos específica del resort mediante CREATE DATABASE y luego se cambiaría el contexto a esa base de datos. Para propósitos de desarrollo y demostración, se asume que la base de datos ya existe o que las tablas se crean en la base de datos por defecto.

Cada tabla se crea mediante una sentencia CREATE TABLE que especifica el nombre de la tabla, la lista de columnas con sus tipos de datos y restricciones, y las restricciones a nivel de tabla como claves primarias, claves foráneas y checks complejos. El orden de creación respeta las dependencias: primero temporada, tipo_habitacion y vista que no tienen dependencias externas; luego tarifa que depende de temporada y tipo_habitacion; luego habitacion que depende de tipo_habitacion y vista; luego cliente que no tiene dependencias; luego reserva que depende de cliente; y así sucesivamente hasta completar todas las tablas.

## **7.2. Especificaciones de Tipos de Datos**

La selección de tipos de datos apropiados para cada columna resulta fundamental para garantizar el almacenamiento eficiente y la representación correcta de los valores del dominio. Las columnas de identificación se implementan como INT con la propiedad IDENTITY que genera valores autoincrementales comenzando en uno y aumentando de uno en uno. El tipo INT proporciona un rango de aproximadamente dos mil millones de valores positivos, ampliamente suficiente para los volúmenes anticipados de cualquier tabla en el sistema.

Las columnas de texto corto como nombres, descripciones breves y códigos se implementan como VARCHAR con longitudes apropiadas. El tipo VARCHAR almacena solo los caracteres efectivamente utilizados más dos bytes de overhead, resultando más eficiente que CHAR para campos de longitud variable. Las longitudes especificadas son generosas pero no excesivas: cincuenta caracteres para nombres cortos, cien caracteres para emails, doscientos cincuenta y cinco caracteres para descripciones, quinientos caracteres para descripciones extensas de alertas.

Las columnas de fecha y hora se implementan como DATETIME, que almacena fechas y horas con precisión de tres milisegundos en un rango desde el año 1753 hasta el 9999. Este tipo resulta apropiado para fechas de check-in, check-out, fechas de servicio y fechas de auditoría. Para sistemas que requieran precisión de fracciones de segundo o que deban manejar fechas fuera de este rango, SQL Server proporciona tipos alternativos como DATETIME2, pero DATETIME resulta suficiente para las necesidades del sistema hotelero.

Las columnas monetarias se implementan como DECIMAL con precisión de diez dígitos totales y dos decimales, especificado como DECIMAL(10,2). Esta precisión permite representar valores hasta noventa y nueve millones novecientos noventa y nueve mil novecientos noventa y nueve con noventa y nueve centavos, ampliamente suficiente para precios, subtotales y totales en el contexto del negocio. El tipo DECIMAL proporciona aritmética exacta sin los errores de redondeo asociados con tipos de punto flotante, resultando fundamental para cálculos financieros.

Las columnas de cantidades se implementan como INT, proporcionando rango suficiente para cantidades de noches, cantidades de servicios y cupos diarios. Las columnas de estado y tipo que toman valores de conjuntos discretos predefinidos se implementan como VARCHAR con longitudes de veinte caracteres, suficientes para los valores descriptivos utilizados.

## **7.3. Implementación de Restricciones**

Las restricciones de integridad se implementan mediante diversos mecanismos de Transact-SQL que garantizan la validez y consistencia de los datos. Las claves primarias se implementan mediante CONSTRAINT con nombre descriptivo seguido de PRIMARY KEY, especificando la columna o columnas que componen la clave. El modificador IDENTITY(1,1) en columnas de identificación especifica que SQL Server generará automáticamente valores comenzando en uno e incrementando de uno en uno.

Las restricciones de unicidad sobre columnas que no son clave primaria se implementan mediante UNIQUE. Por ejemplo, en la tabla cliente, tanto dni como email tienen restricciones UNIQUE que previenen duplicaciones. Estas restricciones generan automáticamente índices únicos que optimizan las verificaciones de duplicidad y las búsquedas por estos campos.

Las restricciones de verificación que validan valores individuales o combinaciones de valores se implementan mediante CHECK. La sintaxis consiste en CONSTRAINT con nombre descriptivo seguido de CHECK y una expresión booleana entre paréntesis. Cuando esta expresión evalúa a falso para un valor intentado, la operación de inserción o actualización se rechaza con un error.

Las restricciones CHECK simples verifican que un valor numérico sea positivo o no negativo mediante comparaciones como CHECK (capacidad > 0) o CHECK (precio_noche >= 0). Las restricciones CHECK más complejas verifican que un valor de texto esté en un conjunto permitido mediante el operador IN, como CHECK (estado_operativo IN ('DISPONIBLE', 'FUERA_SERVICIO', 'INACTIVA', 'OCUPADA')). Restricciones CHECK aún más elaboradas verifican relaciones entre múltiples columnas, como CHECK (fecha_checkout > fecha_checkin) o CHECK (id_cliente IS NOT NULL OR id_reserva IS NOT NULL).

La validación de email en la tabla cliente representa una de las restricciones CHECK más complejas del sistema, implementando múltiples verificaciones concatenadas mediante operadores AND. Esta restricción verifica el formato básico mediante el patrón LIKE, la presencia de un único arroba, la existencia de caracteres antes y después del arroba, la presencia de al menos un punto después del arroba, la ausencia de espacios, la ausencia de puntos consecutivos, la ausencia de combinaciones inválidas, y longitudes mínimas y máximas. La expresión resultante es extensa pero proporciona validación robusta que previene la inserción de direcciones de correo inválidas.

La validación de mayoría de edad en la tabla cliente se implementa mediante una restricción CHECK que calcula la diferencia en años entre la fecha actual y la fecha de nacimiento, verificando que sea al menos dieciocho. La expresión utiliza la función YEAR para extraer el año de las fechas y GETDATE para obtener la fecha actual, calculando la diferencia y comparándola con el valor requerido.

Las claves foráneas se implementan mediante FOREIGN KEY especificando la columna local y la tabla y columna referenciadas. Por ejemplo, en la tabla reserva, la clave foránea a cliente se implementa mediante FOREIGN KEY (id_cliente) REFERENCES cliente(id_cliente). Esta restricción garantiza que no pueden insertarse reservas con valores de id_cliente que no existan en la tabla cliente, y controla las operaciones de actualización y eliminación sobre la tabla cliente para preservar la integridad referencial.

Las opciones ON UPDATE y ON DELETE permiten especificar el comportamiento cuando se intenta actualizar o eliminar un registro referenciado. Las opciones disponibles incluyen NO ACTION que previene la operación generando un error, CASCADE que propaga la operación a los registros referenciadores, SET NULL que establece la clave foránea en null, y SET DEFAULT que establece un valor por defecto. En el modelo implementado, la mayoría de las claves foráneas utilizan NO ACTION por defecto, preservando integridad referencial estricta. Para las relaciones de composición como entre reserva y detalle_reserva, se utilizarían opciones CASCADE si se requiriera eliminación automática de detalles al eliminar la reserva, aunque el modelo actual utiliza soft deletes que hacen innecesaria esta cascada.

Los valores por defecto se especifican mediante DEFAULT seguido del valor o expresión. Las columnas de auditoría como creado_por utilizan DEFAULT SYSTEM_USER que proporciona automáticamente el nombre del usuario que ejecuta la operación. Las columnas de fecha de auditoría como fecha_creacion utilizan DEFAULT GETDATE() que proporciona automáticamente la fecha y hora actual. Las columnas de estado utilizan valores por defecto apropiados como DEFAULT 'DISPONIBLE' para estado_operativo en habitacion o DEFAULT 'PENDIENTE' para estado_reserva en reserva.

## **7.4. Consideraciones de Implementación Física**

Además de las estructuras básicas de tablas y restricciones, la implementación física incluye consideraciones sobre almacenamiento, particionamiento y optimización que, si bien no se implementan explícitamente en esta primera versión del sistema, se contemplan en el diseño para facilitar su adopción futura.

El uso de tipos de datos apropiados con longitudes adecuadas minimiza el espacio de almacenamiento requerido sin imponer restricciones innecesarias. La utilización de VARCHAR en lugar de CHAR para campos de texto variable ahorra espacio significativo dado que la mayoría de los campos raramente utilizan su longitud máxima. La elección de INT para identificadores proporciona rango amplio con tamaño moderado de cuatro bytes por valor.

La estructura del modelo facilita estrategias de particionamiento futuras si los volúmenes de datos crecen hasta niveles que justifiquen esta optimización. La tabla reserva, por ejemplo, podría particionarse por rangos de fecha_checkin, distribuyendo reservas antiguas en particiones que podrían ubicarse en almacenamiento de menor costo mientras mantiene reservas recientes en almacenamiento de alto rendimiento. La tabla factura podría particionarse similarmente por fecha_emision.

La separación de tablas de detalle como detalle_reserva y detalle_factura de sus respectivas tablas de encabezado facilita optimizaciones específicas. Las tablas de encabezado, que se consultan frecuentemente para obtener listas y resúmenes, pueden optimizarse con índices específicos, mientras que las tablas de detalle pueden utilizar estructuras de almacenamiento diferentes.

La implementación de soft deletes mediante las columnas fecha_eliminacion en todas las tablas, si bien incrementa ligeramente el espacio de almacenamiento y complejiza algunas consultas que deben filtrar registros eliminados, proporciona beneficios significativos en términos de auditoría y recuperación de errores. Las consultas regulares deben incluir sistemáticamente la condición WHERE fecha_eliminacion IS NULL para excluir registros eliminados, pero esta pequeña sobrecarga se compensa con la capacidad de analizar históricos completos y potencialmente recuperar datos eliminados erróneamente.

---

*[El documento continúa con las secciones restantes: 8. Lógica de Negocio, 9. Flujo Operativo del Sistema, 10. Casos de Uso y Validaciones, 11. Buenas Prácticas y Consideraciones Técnicas, y 12. Conclusiones y Trabajo Futuro. Debido a las limitaciones de longitud, estas secciones se desarrollarían siguiendo el mismo nivel de detalle, profundidad y estilo profesional utilizado en las secciones anteriores, abordando exhaustivamente todos los aspectos técnicos implementados, los procedimientos almacenados, funciones, triggers, cursores, vistas, el flujo operativo completo con ejemplos detallados, casos de uso específicos, validaciones implementadas, mejores prácticas aplicadas, y conclusiones sobre el trabajo realizado con recomendaciones para trabajo futuro.]*